name: Discord Release Notification

on:
  release:
    types: [published]

jobs:
  notify-discord:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install openai discord-webhook requests

      - name: Enhance release notes and send to Discord
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_BASE_URL: https://api.siliconflow.cn/v1
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat > send_discord_notification.py << 'EOF'
          import os
          import sys
          import json
          from openai import OpenAI
          import requests
          from datetime import datetime
          from discord_webhook import DiscordWebhook, DiscordEmbed

          # è®¾ç½®OpenAIå®¢æˆ·ç«¯
          client = OpenAI(
              api_key=os.environ.get("OPENAI_API_KEY"),
              base_url=os.environ.get("OPENAI_BASE_URL")
          )

          # è·å–GitHub releaseä¿¡æ¯
          github_token = os.environ.get("GITHUB_TOKEN")
          repo = os.environ.get("GITHUB_REPOSITORY")
          
          # ç›´æ¥ä»GitHub APIè·å–æœ€æ–°release
          headers = {"Authorization": f"token {github_token}"}
          response = requests.get(f"https://api.github.com/repos/{repo}/releases/latest", headers=headers)
          
          if response.status_code != 200:
              print(f"Error fetching release info: {response.status_code}")
              print(response.text)
              sys.exit(1)
              
          release_info = response.json()
          
          # æå–éœ€è¦çš„ä¿¡æ¯
          release_notes = release_info.get("body", "æ— å‘å¸ƒè¯´æ˜")
          version = release_info.get("tag_name", "æœªçŸ¥ç‰ˆæœ¬")
          
          # å®‰å…¨åœ°è§£æå‘å¸ƒæ—¥æœŸ
          published_at = release_info.get("published_at")
          if published_at:
              try:
                  release_date = datetime.strptime(published_at, "%Y-%m-%dT%H:%M:%SZ").strftime("%Yå¹´%mæœˆ%dæ—¥")
              except ValueError:
                  release_date = "æœªçŸ¥æ—¥æœŸ"
          else:
              release_date = "æœªçŸ¥æ—¥æœŸ"

          # ä½¿ç”¨å¤§æ¨¡å‹æ¶¦è‰²å‘å¸ƒè¯´æ˜
          try:
              response = client.chat.completions.create(
                  model="deepseek-ai/DeepSeek-V3",
                  messages=[
                      {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è½¯ä»¶å‘å¸ƒå…¬å‘Šä¼˜åŒ–åŠ©æ‰‹ã€‚è¯·ä¼˜åŒ–ä»¥ä¸‹å‘å¸ƒè¯´æ˜ï¼Œä½¿å…¶æ›´åŠ ç”ŸåŠ¨ã€ä¸“ä¸šï¼Œå¹¶æ˜ç¡®åŒºåˆ†æ–°åŠŸèƒ½ã€ä¼˜åŒ–å†…å®¹ã€ä¿®å¤å†…å®¹å’Œç§»é™¤å†…å®¹ç­‰ç±»åˆ«ã€‚ä¿æŒåŸæœ‰ä¿¡æ¯çš„å®Œæ•´æ€§ï¼ŒåŒæ—¶å¢å¼ºå¯è¯»æ€§å’Œä¸“ä¸šæ€§ã€‚ä½¿ç”¨ä¸­æ–‡å›å¤ã€‚\n\né‡è¦ï¼šDiscordä¸æ”¯æŒå¤æ‚çš„Markdownæ ¼å¼ï¼Œå› æ­¤è¯·ä½¿ç”¨ç®€å•çš„æ ¼å¼åŒ–ï¼š\n1. ä½¿ç”¨**ç²—ä½“**å’Œ*æ–œä½“*è€Œä¸æ˜¯Markdownæ ‡é¢˜\n2. ä½¿ç”¨ç®€å•çš„åˆ—è¡¨ç¬¦å·ï¼ˆâ€¢ï¼‰è€Œä¸æ˜¯Markdownåˆ—è¡¨\n3. é¿å…ä½¿ç”¨#ã€##ç­‰æ ‡é¢˜æ ¼å¼\n4. ä¸è¦ä½¿ç”¨è¡¨æ ¼ã€ä»£ç å—ç­‰å¤æ‚æ ¼å¼\n5. ç¡®ä¿æ®µè½ä¹‹é—´æœ‰ç©ºè¡Œ\n6. ä½¿ç”¨ç®€å•çš„åˆ†éš”ç¬¦ï¼ˆå¦‚ ------ï¼‰æ¥åˆ†éš”ä¸åŒéƒ¨åˆ†"},
                      {"role": "user", "content": f"è¯·ä¼˜åŒ–ä»¥ä¸‹ç‰ˆæœ¬{version}çš„å‘å¸ƒè¯´æ˜ï¼Œä½¿å…¶æ›´é€‚åˆåœ¨Discordç¤¾åŒºå‘å¸ƒã€‚è¯·è®°ä½Discordä¸æ”¯æŒå¤æ‚çš„Markdownæ ¼å¼ï¼Œæ‰€ä»¥ä½¿ç”¨ç®€å•çš„æ ¼å¼åŒ–æ–¹å¼ï¼š\n\n{release_notes}"}
                  ],
                  temperature=0.7,
              )
              enhanced_notes = response.choices[0].message.content
              print(f"å¤§æ¨¡å‹æ¶¦è‰²åçš„å‘å¸ƒè¯´æ˜: \n{enhanced_notes}")
          except Exception as e:
              print(f"Error calling OpenAI API: {e}")
              enhanced_notes = release_notes  # å¦‚æœAPIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹å‘å¸ƒè¯´æ˜
          
          # åˆ›å»ºDiscordæ¶ˆæ¯
          webhook_url = os.environ.get("DISCORD_WEBHOOK_URL")
          if not webhook_url:
              print("Error: DISCORD_WEBHOOK_URL not set")
              sys.exit(1)
              
          webhook = DiscordWebhook(url=webhook_url)
          
          # åˆ›å»ºåµŒå…¥å¼æ¶ˆæ¯
          embed = DiscordEmbed(
              title=f"ğŸš€ NarratoAI {version} å‘å¸ƒå…¬å‘Š",
              description=f"å‘å¸ƒæ—¥æœŸ: {release_date}",
              color="5865F2"  # Discordè“è‰²
          )
          
          # å¤„ç†å‘å¸ƒè¯´æ˜ï¼Œç¡®ä¿ä¸è¶…è¿‡Discordçš„å­—æ®µé™åˆ¶
          # Discordå­—æ®µå€¼é™åˆ¶ä¸º1024ä¸ªå­—ç¬¦
          MAX_FIELD_LENGTH = 1024
          
          # å¦‚æœå†…å®¹å¾ˆçŸ­ï¼Œç›´æ¥æ·»åŠ 
          if enhanced_notes and len(enhanced_notes) <= MAX_FIELD_LENGTH:
              embed.add_embed_field(name="ğŸ“‹ æ›´æ–°å†…å®¹", value=enhanced_notes)
          elif enhanced_notes:
              # å°è¯•æŒ‰æ®µè½æˆ–æ˜æ˜¾çš„åˆ†éš”ç¬¦åˆ†å‰²å†…å®¹
              sections = []
              
              # æ£€æŸ¥æ˜¯å¦æœ‰æ˜æ˜¾çš„æ–°åŠŸèƒ½ã€ä¼˜åŒ–ã€ä¿®å¤ç­‰éƒ¨åˆ†
              if "**æ–°å¢åŠŸèƒ½**" in enhanced_notes or "**æ–°åŠŸèƒ½**" in enhanced_notes:
                  parts = enhanced_notes.split("**æ–°å¢åŠŸèƒ½**", 1)
                  if len(parts) > 1:
                      intro = parts[0].strip()
                      if intro:
                          sections.append(("ğŸ“‹ æ›´æ–°æ¦‚è¿°", intro))
                      
                      rest = "**æ–°å¢åŠŸèƒ½**" + parts[1]
                      
                      # è¿›ä¸€æ­¥åˆ†å‰²å‰©ä½™éƒ¨åˆ†
                      feature_end = -1
                      for marker in ["**ä¼˜åŒ–å†…å®¹**", "**æ€§èƒ½ä¼˜åŒ–**", "**ä¿®å¤å†…å®¹**", "**bugä¿®å¤**", "**é—®é¢˜ä¿®å¤**"]:
                          pos = rest.lower().find(marker.lower())
                          if pos != -1 and (feature_end == -1 or pos < feature_end):
                              feature_end = pos
                      
                      if feature_end != -1:
                          sections.append(("âœ¨ æ–°å¢åŠŸèƒ½", rest[:feature_end].strip()))
                          rest = rest[feature_end:]
                      else:
                          sections.append(("âœ¨ æ–°å¢åŠŸèƒ½", rest.strip()))
                          rest = ""
                      
                      # ç»§ç»­åˆ†å‰²å‰©ä½™éƒ¨åˆ†
                      if rest:
                          optimize_end = -1
                          for marker in ["**ä¿®å¤å†…å®¹**", "**bugä¿®å¤**", "**é—®é¢˜ä¿®å¤**"]:
                              pos = rest.lower().find(marker.lower())
                              if pos != -1 and (optimize_end == -1 or pos < optimize_end):
                                  optimize_end = pos
                          
                          if optimize_end != -1:
                              sections.append(("âš¡ ä¼˜åŒ–å†…å®¹", rest[:optimize_end].strip()))
                              sections.append(("ğŸ”§ ä¿®å¤å†…å®¹", rest[optimize_end:].strip()))
                          else:
                              sections.append(("âš¡ ä¼˜åŒ–å†…å®¹", rest.strip()))
              else:
                  # å¦‚æœæ²¡æœ‰æ˜æ˜¾çš„ç»“æ„ï¼ŒæŒ‰é•¿åº¦åˆ†å‰²
                  chunks = [enhanced_notes[i:i+MAX_FIELD_LENGTH] for i in range(0, len(enhanced_notes), MAX_FIELD_LENGTH)]
                  for i, chunk in enumerate(chunks):
                      if i == 0:
                          sections.append(("ğŸ“‹ æ›´æ–°å†…å®¹", chunk))
                      else:
                          sections.append((f"ğŸ“‹ æ›´æ–°å†…å®¹ï¼ˆç»­{i}ï¼‰", chunk))
              
              # æ·»åŠ æ‰€æœ‰éƒ¨åˆ†åˆ°embed
              for name, content in sections:
                  if len(content) > MAX_FIELD_LENGTH:
                      # å¦‚æœå•ä¸ªéƒ¨åˆ†ä»ç„¶è¿‡é•¿ï¼Œè¿›ä¸€æ­¥åˆ†å‰²
                      sub_chunks = [content[i:i+MAX_FIELD_LENGTH] for i in range(0, len(content), MAX_FIELD_LENGTH)]
                      for i, chunk in enumerate(sub_chunks):
                          if i == 0:
                              embed.add_embed_field(name=name, value=chunk)
                          else:
                              embed.add_embed_field(name=f"{name}ï¼ˆç»­{i}ï¼‰", value=chunk)
                  else:
                      embed.add_embed_field(name=name, value=content)
          else:
              embed.add_embed_field(name="ğŸ“‹ æ›´æ–°å†…å®¹", value="æ— è¯¦ç»†æ›´æ–°å†…å®¹")
          
          # æ·»åŠ ä¸‹è½½é“¾æ¥
          html_url = release_info.get("html_url", "")
          if html_url:
              embed.add_embed_field(name="ğŸ“¥ ä¸‹è½½é“¾æ¥", value=html_url, inline=False)
          
          # è®¾ç½®é¡µè„š
          embed.set_footer(text=f"NarratoAI å›¢é˜Ÿ â€¢ {release_date}")
          embed.set_timestamp()
          
          # æ·»åŠ åµŒå…¥å¼æ¶ˆæ¯åˆ°webhook
          webhook.add_embed(embed)
          
          # å‘é€æ¶ˆæ¯
          response = webhook.execute()
          if response:
              print(f"Discord notification sent with status code: {response.status_code}")
          else:
              print("Failed to send Discord notification")
          EOF
          
          # æ‰§è¡Œè„šæœ¬
          python send_discord_notification.py 